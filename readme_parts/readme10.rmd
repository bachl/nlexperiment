---
output: 
  html_document: 
    keep_md: yes
    self_contained: no
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "img/README-"
)
```


```{r, echo = FALSE}
library(nlexperiment)
nl_netlogo_path("c:/Program Files (x86)/NetLogo 5.2.0") 
```

## Parameter fitting and optimization / L-BFGS-B
Using experiment definition from 
[previous chapter: best-fit criteria function](#best-fit criteria function)
we could search the parameter space to optimize the cost function.

```{r echo=FALSE}
cond_cost_function <- function(value, minval, maxval) {
  # squared relative deviation if value outside accepted range
  ifelse(
    minval > value  | value > maxval,
    ret <- ((mean(minval,maxval) - value) / mean(minval,maxval))^2,
    0
  )
}
```


```{r p10experiment, echo=FALSE}
#set.seed(4)

experiment <- nl_experiment( 
  model_file = 
    system.file("netlogo_models/SM2_Hoopoes.nlogo", package = "nlexperiment"),
  
  setup_commands = c("setup", "repeat 24 [go]"), # 2 years of warming-up
  go_command = "repeat 12 [go]",                 # iteration is per year
  iterations = 20,                               # run for 20 years
  repetitions = 10,                              # repeat simulation 10 times
#   random_seed = 
#     as.integer(runif(10,-2147483648,2147483647)),# reproducibility 
  
  param_values = list(                           # "full factor design"
    scout_prob = seq(from = 0.00, to = 0.50, by = 0.05),
    survival_prob = seq(from = 0.950, to = 1.000, by = 0.005)
  ),
  mapping = c(                                   # map NetLogo variables
    scout_prob = "scout-prob", 
    survival_prob = "survival-prob"
  ),
  
  step_measures = measures(                      # NetLogo reporters per step
    abund = "month-11-count",             
    alpha = "month-11-alpha",                 
    patches_count = "count patches"
  ),

  eval_criteria = criteria(                      # evaluation per each run
    abundance = mean(step$abund),
    variation = sd(step$abund),
    vacancy = mean(step$alpha / step$patches_count)
  ),
  
  eval_aggregate_fun = mean,                     # mean value (10 repetitions)
  
  eval_mutate = criteria(                        # add categorical values
    cost = 
      cond_cost_function(abundance, 115, 135) +
      cond_cost_function(variation, 10, 15) +
      cond_cost_function(vacancy, 0.15, 0.30)
  )  
)
```




When using optimization methods we can't pre-define parameter sets because they
are selected as optimization runs. In this scenario the `nl_eval_run` function should be used instead of `nl_run`. 

There are two differences:

* `nl_run_eval` accepts a parameter set and returns a value 
* It requires NetLogo instance - user have to take care to initialize NetLogo and load the model before optimization begins and 
close NetLogo when it is no longer needed (see functions `nl_eval_init` and `nl_eval_close`).

Use `nl_eval_run` _parallel_ option when optimizing stochastic models
with more than a few repetitions needed to evaluate one parameter set. 

There are many R packages for solving optimization problems 
(see [CRAN Task View](https://cran.r-project.org/web/views/Optimization.html)).
This example use **L-BFGS-B method** with standard `stats::optim` function.
See also Thiele, Kurth & Grimm (2014) chapter 
[2.28 Gradient and quasi-Newton methods](http://jasss.soc.surrey.ac.uk/17/3/11.html#sectionGQNM).

```{r p10optim, cache=TRUE}
# parameter range from experiment
param_range <- nl_get_param_range(experiment)   
 
# initialize evaluation
cl <- nl_eval_init(experiment, parallel = TRUE)

# create callback container to spy what the optim function is doing
trace <- nl_eval_tracer(verbose = FALSE)

#call optimisation function with L-BFGS-B method:
o_result <- optim(
  par = c(0.5, 1.0),  
  nl_eval_run, 
    experiment = experiment, criteria = "cost", 
    call_back = trace$add, parallel = TRUE, cluster = cl,
  method = "L-BFGS-B",
  lower = param_range$lower, upper = param_range$upper, 
  control = list(maxit = 200, trace = 1))

nl_eval_close(parallel = TRUE, cl)

```

```{r}
#final result:
o_result
```

The `trace$add` function colected every iteration of `optim`. 

```{r p10plot}
dat <- trace$get()

library(ggplot2)

ggplot(dat, aes(x=iter_id, y = result)) +
  geom_step() +
  labs(x = "Iteration", y = "Evaluation result")

```

Optim iterations on parameter space:
```{r}


ggplot(dat, aes(x = scout_prob, y = survival_prob, color = pmin(20,result))) +
  #  geom_line(color = "gray", size = 1, ) +
  geom_point(size = 3) +
  geom_point(
    color = "red", 
    data = data.frame(scout_prob = o_result$par[1], survival_prob = o_result$par[2]),
    size = 20, shape = 4) +
  theme_minimal()

```

