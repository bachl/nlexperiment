{"name":"nlexperiment","tagline":"Define and run NetLogo experiments in R","body":"\r\n\r\n\r\n[![](https://travis-ci.org/bergant/nlexperiment.svg)](https://travis-ci.org/bergant/nlexperiment)\r\n\r\n----\r\n<a name=\"nlexperiment\"></a>\r\n![nlexperiment](img/logo.png)\r\n\r\n####Define and run NetLogo experiments in R\r\n\r\nThe goal of **nlexperiment** is to make \r\nexploring NetLogo models with R as simple as possible \r\nwhile keeping advanced functionalities available to\r\nadvanced users.\r\nIt uses [RNetLogo](https://cran.r-project.org/web/packages/RNetLogo/)\r\npackage (Thiele 2014) as an interface to NetLogo.\r\n\r\n\r\n## Installation\r\n\r\n`library(devtools)`   \r\n`install_github(\"bergant/nlexperiment\")`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Simple experiment with fire\r\nThis sample experiment with NetLogo Fire model (Wilensky 1997) demonstrates\r\nhow to create and run minimal experiment. It runs the model with three parameter\r\nvalues (forest density) and exports final NetLogo views to image files:\r\n\r\n\r\n```r\r\nlibrary(nlexperiment)\r\n# Set the path to your NetLogo instalation\r\nnl_netlogo_path(\"c:/Program Files (x86)/NetLogo 5.2.0/\") \r\n\r\n# Create NetLogo experiment object\r\nexperiment <- nl_experiment(\r\n  model_file = file.path(nl_netlogo_path(), \r\n                         \"models/Sample Models/Earth Science/Fire.nlogo\"), \r\n  while_condition = \"any? turtles\",\r\n  param_values = list(density = c(57, 59, 61)),\r\n  random_seed = 1,\r\n  export_view = TRUE\r\n)\r\n```\r\n\r\nRun the experiment:\r\n\r\n```r\r\nresult <- nl_run(experiment)  \r\n```\r\n\r\nFind paths to the exported view image files in `result$export` or just display them by calling `nl_show_views_grid` function:\r\n\r\n\r\n```r\r\nlibrary(ggplot2)\r\nnl_show_views_grid(result, \"density\")\r\n```\r\n\r\n![](img/README-model_view-1.png) \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Observations per each simulation step\r\nFrom statistical point of view, the interesting part of experiment is \r\ngetting some quantitative information. \r\nThis sample demonstrates how to set measures\r\nfor each simulation step.\r\n\r\n```r\r\nexperiment <- nl_experiment(\r\n  model_file = file.path(nl_netlogo_path(), \r\n                         \"models/Sample Models/Earth Science/Fire.nlogo\"), \r\n  while_condition = \"any? turtles\",\r\n  param_values = list(density = c(57, 59, 61)),\r\n  random_seed = 1,\r\n  step_measures = measures(\r\n    percent_burned = \"(burned-trees / initial-trees) * 100\"\r\n  )\r\n)\r\n```\r\n\r\nRun the experiment:\r\n\r\n```r\r\nresult <- nl_run(experiment)\r\n```\r\n\r\nPlot of burned forest as a function of time for different forest densities:\r\n\r\n```r\r\n# get the observation data for step measures\r\ndat <- nl_get_result(result, type = \"step\") \r\n# plot the observations\r\nlibrary(ggplot2)\r\nggplot(dat, mapping = aes(x = step_id, y = percent_burned)) + \r\n  geom_step() +\r\n  facet_grid(. ~ density) +\r\n  labs(y = \"Percent burned\", x = \"Iteration\")\r\n```\r\n\r\n![](img/README-model_step_plot-1.png) \r\n\r\n*Note: values `run_id` and `step_id` are included in the `results$step` by default.\r\nParameter values are included only by reference to `parameter_set_id`. The \r\nfunction `nl_get_result` joins parameter sets to observation data.*\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Observations per each simulation run\r\nIn this example\r\n\r\n* two measures _per simulation run_ are defined (values are reported at the end \r\nof each simulation run),\r\n* the model will be run repetedly `30` times for every parameter value\r\n* and the model is running with `parallel` option (to save some time)\r\n\r\n\r\n```r\r\nexperiment <- nl_experiment(\r\n  model_file = file.path(nl_netlogo_path(), \r\n                         \"models/Sample Models/Earth Science/Fire.nlogo\"), \r\n  while_condition = \"any? turtles\",\r\n  repetitions = 30,\r\n  run_measures = measures(\r\n    percent_burned = \"(burned-trees / initial-trees) * 100\",\r\n    progress = \"max [pxcor] of patches with [pcolor > 0 and pcolor < 55]\"\r\n  ),\r\n  param_values = list(\r\n    density = seq(from = 55, to = 62, by = 1)\r\n  )\r\n)\r\n```\r\n\r\nRun the experiment with `parallel` option:\r\n\r\n\r\n```r\r\nresult <- nl_run(experiment, parallel = TRUE)\r\n# Join observations with parameter set values:\r\ndat <- nl_get_run_result(result, add_parameters = TRUE)\r\n```\r\n\r\nPlot the results - percent burned as a function of density:\r\n\r\n```r\r\n# plot percent burned by density\r\nlibrary(ggplot2)\r\nggplot(dat, mapping = aes(x = factor(density), y = percent_burned) ) + \r\n  geom_violin() +\r\n  #geom_jitter(position = position_jitter(width = .1), alpha = 0.3) +\r\n  labs(x = \"Forest density\", y = \"Percent burned\")\r\n```\r\n\r\n![](img/README-p3plot1-1.png) \r\n\r\nFire advances from left to right. It is interesting to observe\r\nfinal fire position (left border = 0 and right = 1) as a function of density.\r\n\r\n```r\r\nggplot(dat, mapping = aes(x = factor(density), y = progress/250 + 0.5) ) + \r\n  geom_jitter(position = position_jitter(width = .1), alpha = 0.3)  +\r\n  theme_minimal() +\r\n  labs(x = \"Forest density\", y = \"Fire progress\")\r\n```\r\n\r\n![](img/README-p3plot2-1.png) \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Reading agent variables\r\nWhile `run_measures` (see [Observation per run](#observations-per-each-simulation-run)) is good enough for aggregate measures, sometimes we need values for each agent individually.\r\nExample shows usage of `agents_after` parameter to get vertices from Preferential attachment\r\nmodel.\r\n\r\n\r\n```r\r\nexperiment <- nl_experiment(\r\n  model_file = file.path(nl_netlogo_path(), \r\n                         \"models/Sample models/Networks/Preferential attachment.nlogo\"), \r\n  iterations = 50,\r\n  agents_after = list(\r\n    vertices = agent_set(\r\n      vars = c(\"who\", \"xcor\", \"ycor\"), \r\n      agents = \"turtles\"),\r\n    edges = agent_set(\r\n      vars = c(e1 = \"[who] of end1\", e2 =\"[who] of end2\"), \r\n      agents = \"links\")\r\n  ),\r\n  repetitions = 2,\r\n  random_seed = c(42, 69)\r\n)\r\n```\r\n\r\n_Note:_\r\n\r\n* _Here random seed is defined as a vector. It is applied to each repetition respectively._\r\n* _Variables in agent set may or may not include variable names._\r\n* _Element `agents_before` is analogous tp `agents_after` - it just gets the data before model runs.)_\r\n\r\nRun experiment\r\n\r\n```r\r\nresult <- nl_run(experiment)\r\n#> Warning: Parameter sets not defined. Using default parameters\r\n```\r\n\r\nShow graph by using **igraph** package:\r\n\r\n\r\n```r\r\nlibrary(igraph, quietly = TRUE, warn.conflicts = FALSE)\r\npar(mfrow=c(1,2), mai=c(0,0,0,0))\r\nfor(i in 1:experiment$run_options$repetitions) {\r\n  g_edges <- subset(result$agents_after$edges, run_id == i)\r\n  g1 <- graph.data.frame(g_edges, directed = FALSE)\r\n  V(g1)$size <- sqrt(degree(g1))*6\r\n  V(g1)$label <- ifelse(as.numeric(V(g1)$name) < 4, as.numeric(V(g1)$name), NA)\r\n  plot.igraph(g1, margin = 0, \r\n              vertex.label.font = V(g1)$size * 0.07,\r\n              vertex.label.color = \"white\",\r\n              vertex.color=\"darkseagreen4\",\r\n              edge.color = \"gray\",\r\n              vertex.frame.color=\"#ffffff\",\r\n              edge.curved=.1\r\n  )\r\n}\r\n```\r\n\r\n![](img/README-p6Sigraph-1.png) \r\n\r\n_Note:_\r\n\r\n* _Data frame `result$agents_after$edges` includes variables from all simulation runs._\r\n* _Use `param_space_id` and/or `run_id` columns to subset individual run or parameter combination_\r\n\r\n\r\n## Reading patches\r\nGetting patches information is analogous to reading agents' data from NetLogo model:\r\n\r\n\r\n```r\r\nexperiment2 <- nl_experiment( \r\n  model_file = file.path(nl_netlogo_path(), \r\n                         \"models/Sample Models/Biology/Fur.nlogo\"), \r\n  iterations = 20,                                     \r\n  \r\n  param_values = list(\r\n    ratio = c(0.3, 0.35, 0.4, 0.45)\r\n  ),\r\n  patches_after = list(\r\n    patches = patch_set(\r\n      vars = c(\"pxcor\", \"pycor\", \"pcolor\"),\r\n      patches = \"patches\"\r\n    )\r\n  ),\r\n  random_seed = 2\r\n)\r\n\r\nresult2 <- nl_run(experiment2)\r\n\r\nnl_show_patches(result2, x_param = \"ratio\") +\r\n  ggplot2::scale_fill_manual(values = c(\"black\",\"white\"))\r\n```\r\n\r\n![](img/README-p6E2-1.png) \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Simple parameter sets definition\r\nThe following example is using Ant model (Wilensky 1997) to show \r\nsimple parameter sets definition and parameter mapping.\r\n\r\n\r\n```r\r\nexperiment <- nl_experiment(\r\n  model_file = file.path(nl_netlogo_path(), \r\n                         \"models/Sample Models/Biology/Ants.nlogo\"), \r\n  iterations = 150,\r\n  step_measures = measures(\r\n    pile1 = \"sum [food] of patches with [pcolor = cyan]\",  \r\n    pile2 = \"sum [food] of patches with [pcolor = sky]\",  \r\n    pile3 = \"sum [food] of patches with [pcolor = blue]\"  \r\n  ),\r\n  param_values = list(\r\n    population = 125,\r\n    diffusion_rate = c(50, 70),\r\n    evaporation_rate = c(5, 10, 15)\r\n  ),\r\n  mapping = c(\r\n    diffusion_rate = \"diffusion-rate\",\r\n    evaporation_rate = \"evaporation-rate\"\r\n    ),\r\n  random_seed = 2,\r\n  export_view = TRUE\r\n)\r\n```\r\n\r\n_Note:_\r\n\r\n* _When parameters are defined as a list of value vecors, parameter sets are\r\n  constructed as combination of all possible parameter value combination_\r\n* _It is not required to include all parameters in mapping. Variable `population` \r\nis used as is._\r\n* _NetLogo identifiers may include some ASCII characters `(?=*!<>:#+/%$^'&-)`\r\nthat makes the R part of data manipulation rather uncomfortable._\r\n* _Element `mapping` maps `difussion_rate` and `evaporation_rate` names to NetLogo variables `diffusion-rate` and `evaporation-rate`._\r\n\r\n\r\nRun experiment\r\n\r\n```r\r\nresults <- nl_run(experiment)  \r\n```\r\n\r\nShow views\r\n\r\n```r\r\nnl_show_views_grid(results, \"evaporation_rate\", \"diffusion_rate\")\r\n```\r\n\r\n![](img/README-p5ShowViews-1.png) \r\n\r\nShow remaining food by difussion rate and evaporation rate for all food piles\r\n\r\n```r\r\nlibrary(tidyr)\r\ndat <- nl_get_step_result(results)\r\ndat <- tidyr::gather(dat, pile, value, pile1, pile2, pile3)\r\n\r\nlibrary(ggplot2)\r\nggplot(dat, aes(x = step_id, y = value, color = pile) ) +\r\n  geom_line() +\r\n  facet_grid(diffusion_rate ~ evaporation_rate)\r\n```\r\n\r\n![](img/README-p5plot-1.png) \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Parameter space mapping\r\nThe following example is using NetLogo Fur model (Wilensky 2003) to show \r\nexplicit definition of parameter sets and parameter mapping.\r\n\r\nThere are 5 parameters in the NetLogo Fur model: \r\n\r\n* `ratio` \r\n* `outer-radius-y`\r\n* `inner-radius-y`\r\n* `outer-radius-x`\r\n* `inner-radius-x`\r\n\r\nBut considering constraints and model symmetry\r\nwe can reduce the parameters to:\r\n\r\n* `ratio` (the inhibitor concentration parameter)\r\n* `radius_diff` (the difference between x and y radius) and\r\n* `gap` (distance between inner and outer ellipse)\r\n\r\n(for simplicity let's keep the `gap` between the circles constant):\r\n\r\n\r\n\r\n```r\r\nexperiment <- nl_experiment( \r\n  model_file = file.path(nl_netlogo_path(), \r\n                         \"models/Sample Models/Biology/Fur.nlogo\"), \r\n  iterations = 20,                                     \r\n\r\n  param_values = {                                  # Parameter sets:\r\n    param_sets <- expand.grid(                      #   all combinations of\r\n        gap = 3,                                    #   gap, ratio and ry- rx\r\n        radius_diff = seq(0, 2, by = 0.5), \r\n        ratio = seq(0.30, 0.65, by = 0.05)\r\n    )\r\n    transform(param_sets,                           # Transform to NetLogo\r\n      inner_radius_x = 3,                           #   variables\r\n      outer_radius_x = 3 + gap,\r\n      inner_radius_y = 3 + radius_diff,\r\n      outer_radius_y = 3 + radius_diff + gap\r\n    )\r\n  },\r\n  mapping = c(\r\n    gap = \"\",\r\n    radius_diff = \"\",\r\n    inner_radius_x = \"inner-radius-x\",\r\n    outer_radius_x = \"outer-radius-x\",\r\n    inner_radius_y = \"inner-radius-y\",\r\n    outer_radius_y = \"outer-radius-y\"\r\n  ),\r\n  patches_after = list(\r\n    patches = patch_set(\r\n      vars = c(\"pxcor\", \"pycor\", \"pcolor\"),\r\n      patches = \"patches\"\r\n    )\r\n  ),  \r\n  random_seed = 3\r\n)\r\n```\r\n\r\n_Note:_ \r\n\r\n* _Element `param_values` is set by a data frame with explicit parameter sets_ \r\n* _Variables `gap` and `radius_diff` must be mapped to empty string (not NetLogo variables)._\r\n\r\n\r\nRun experiment\r\n\r\n```r\r\nresult <- nl_run(experiment, parallel = TRUE, max_cores = 3)    \r\n```\r\n\r\nShow resulting fur patterns:\r\n\r\n```r\r\nlibrary(ggplot2)\r\nnl_show_patches(result, x_param = \"ratio\", y_param = \"radius_diff\") + \r\n  scale_fill_manual(values = c(\"black\",\"white\")) +\r\n  labs(y=expression(radius[y] - radius[x]), title = \"Fur patterns (gap = 3)\")\r\n```\r\n\r\n![](img/README-p7ShowViews-1.png) \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Categorical criteria function\r\nThis example uses NetLogo Hoopoes model from Railsback & Grimm (2011).\r\nHere the approach is the same as in the Thiele, Kurth & Grimm (2014)\r\nexcept using the **nlexperiment** framework instead of original R scripts.\r\nSee Factorial design and Latin hypercube sampling chapters in the \r\n[article](http://jasss.soc.surrey.ac.uk/17/3/11.html). \r\n\r\nDefine an experiment with evaluation criteria  \r\n*abundance*, *variation* and *vacancy* (see `eval_criteria` element)\r\nand categorical boolean criteria based on satisfactory ranges (see `eval_mutate`):\r\n\r\n\r\n```r\r\nexperiment <- nl_experiment( \r\n  model_file = \r\n    system.file(\"netlogo_models/SM2_Hoopoes.nlogo\", package = \"nlexperiment\"),\r\n  \r\n  setup_commands = c(\"setup\", \"repeat 24 [go]\"), # 2 years of warming-up\r\n  go_command = \"repeat 12 [go]\",                 # iteration is per year\r\n  iterations = 20,                               # run for 20 years\r\n  repetitions = 10,                              # repeat simulation 10 times\r\n  \r\n  param_values = list(                           # \"full factor design\"\r\n    scout_prob = seq(from = 0.00, to = 0.50, by = 0.05),\r\n    survival_prob = seq(from = 0.950, to = 1.000, by = 0.005)\r\n  ),\r\n  mapping = c(                                   # map NetLogo variables\r\n    scout_prob = \"scout-prob\", \r\n    survival_prob = \"survival-prob\"\r\n  ),\r\n  \r\n  step_measures = measures(                      # NetLogo reporters per step\r\n    abund = \"month-11-count\",             \r\n    alpha = \"month-11-alpha\",                 \r\n    patches_count = \"count patches\"\r\n  ),\r\n\r\n  eval_criteria = criteria(                      # evaluation per each run\r\n    abundance = mean(step$abund),\r\n    variation = sd(step$abund),\r\n    vacancy = mean(step$alpha / step$patches_count)\r\n  ),\r\n  \r\n  eval_aggregate_fun = mean,                     # mean value (10 repetitions)\r\n  \r\n  eval_mutate = criteria(                        # categorical criteria\r\n    c_abundance = abundance > 115 & abundance < 135,\r\n    c_variation = variation > 10 & variation < 15,\r\n    c_vacancy = vacancy > 0.15 & vacancy < 0.30\r\n  )  \r\n)\r\n```\r\n\r\n_Note:_ \r\n\r\n* _The iteration is set to 12 times calling `go` procedure (1 iteration step = 12 NetLogo ticks)_\r\n* _When using list of parameter values, full parameter set is evaluated_\r\n* _Criteria function receives all the results from model run and returns numerical vector_ \r\n* _Results from criteria function are aggregated by parameter sets over 10 repetitions_\r\n* _Additionally categorical criteria is defined with ranges_\r\n\r\nRun experiment:\r\n\r\n```r\r\nresult <- nl_run(experiment, parallel = TRUE) \r\n# get the data (criteria)\r\ndat <- nl_get_result(result, type = \"criteria\") \r\n```\r\n\r\nReturned data frame includes parameter sets with evaluation criteria:\r\n\r\n```r\r\nstr(dat)\r\n#> 'data.frame':\t121 obs. of  9 variables:\r\n#>  $ scout_prob   : num  0 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 ...\r\n#>  $ survival_prob: num  0.95 0.95 0.95 0.95 0.95 0.95 0.95 0.95 0.95 0.95 ...\r\n#>  $ param_set_id : int  1 2 3 4 5 6 7 8 9 10 ...\r\n#>  $ abundance    : num  4.67 4.46 5.08 6.18 5.35 ...\r\n#>  $ variation    : num  9.15 8.15 9.67 11.12 9.58 ...\r\n#>  $ vacancy      : num  0.981 0.98 0.98 0.966 0.976 ...\r\n#>  $ c_abundance  : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...\r\n#>  $ c_variation  : logi  FALSE FALSE FALSE TRUE FALSE FALSE ...\r\n#>  $ c_vacancy    : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...\r\n```\r\n\r\nPlot categorical criteria on the model parameter space:\r\n\r\n```r\r\nlibrary(ggplot2)\r\n\r\nggplot(dat, aes(x = scout_prob, y = survival_prob)) +\r\n  geom_point() +\r\n  geom_point(data = subset(dat, c_abundance), color = \"red\", size = 7, shape = 2) +\r\n  geom_point(data = subset(dat, c_variation), color = \"steelblue\", size = 7, shape = 3) +\r\n  geom_point(data = subset(dat, c_vacancy), color = \"darkgreen\", size = 7, shape = 4) +\r\n  theme_minimal()\r\n```\r\n\r\n![](img/README-p8SplotParameterSpace-1.png) \r\n\r\nInstead of exploring parameter space with (full) factorial design \r\nwe can use sampling methods. Below is an example with **latin hypercube sampling** \r\nfrom **tgp** package:\r\n\r\n\r\n```r\r\n# use Latin Hypercube sampling to sample 50 parameter sets\r\nlibrary(tgp)\r\nparam_sets <- lhs(n=50, rect=matrix(c(0.0, 0.95, 0.5, 1.0), 2)) \r\nparam_sets <- setNames(as.data.frame(param_sets), c(\"scout_prob\", \"survival_prob\")) \r\n```\r\n\r\nTo change only parameter sets use `nl_set_param_values`\r\ninstead of repeating all experiment definitions with `nl_experiment`:\r\n\r\n```r\r\n# change parameters of existing experiment\r\nexperiment <- nl_set_param_values( experiment,\r\n  param_values = param_sets\r\n)\r\n```\r\n\r\nRun the model with new parameters:\r\n\r\n```r\r\nresult2 <- nl_run(experiment, parallel = TRUE) \r\n# get the data (criteria)\r\ndat2 <- nl_get_result(result2, type = \"criteria\")\r\n```\r\n\r\n\r\n\r\n```r\r\nggplot(dat2, aes(x = scout_prob, y = survival_prob)) +\r\n  geom_point() +\r\n  geom_point(data = subset(dat2, c_abundance), color = \"red\", size = 7, shape = 2) +\r\n  geom_point(data = subset(dat2, c_variation), color = \"steelblue\", size = 7, shape = 3) +\r\n  geom_point(data = subset(dat2, c_vacancy), color = \"seagreen\", size = 7, shape = 4) +\r\n  theme_minimal()\r\n```\r\n\r\n![](img/README-p8Aggregate2-1.png) \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Best-fit criteria function\r\nAs in Thiele, Kurth & Grimm (2014) define general cost function which\r\nis 0 when criteria are met and > 0 outside acceptable ranges:\r\n\r\n\r\n```r\r\ncond_cost_function <- function(value, minval, maxval) {\r\n  # squared relative deviation if value outside accepted range\r\n  ifelse(\r\n    minval > value  | value > maxval,\r\n    ret <- ((mean(minval,maxval) - value) / mean(minval,maxval))^2,\r\n    0\r\n  )\r\n}\r\n```\r\n\r\n_Note: the function can use a vector in `value` attribute_\r\n\r\nThe rest is analogous to the previous example (categorical criteria) except \r\nwhen `eval_mutate` defines different criteria:\r\n\r\n\r\n```r\r\nexperiment <- nl_experiment( \r\n  model_file = \r\n    system.file(\"netlogo_models/SM2_Hoopoes.nlogo\", package = \"nlexperiment\"),\r\n  \r\n  setup_commands = c(\"setup\", \"repeat 24 [go]\"), # 2 years of warming-up\r\n  go_command = \"repeat 12 [go]\",                 # iteration is per year\r\n  iterations = 20,                               # run for 20 years\r\n  repetitions = 10,                              # repeat simulation 10 times\r\n  \r\n  param_values = list(                           # \"full factor design\"\r\n    scout_prob = seq(from = 0.00, to = 0.50, by = 0.05),\r\n    survival_prob = seq(from = 0.950, to = 1.000, by = 0.005)\r\n  ),\r\n  mapping = c(                                   # map NetLogo variables\r\n    scout_prob = \"scout-prob\", \r\n    survival_prob = \"survival-prob\"\r\n  ),\r\n  \r\n  step_measures = measures(                      # NetLogo reporters per step\r\n    abund = \"month-11-count\",             \r\n    alpha = \"month-11-alpha\",                 \r\n    patches_count = \"count patches\"\r\n  ),\r\n\r\n  eval_criteria = criteria(                      # evaluation per each run\r\n    abundance = mean(step$abund),\r\n    variation = sd(step$abund),\r\n    vacancy = mean(step$alpha / step$patches_count)\r\n  ),\r\n  \r\n  eval_aggregate_fun = mean,                     # mean value (10 repetitions)\r\n  \r\n  eval_mutate = criteria(                        # add categorical values\r\n    cost = \r\n      cond_cost_function(abundance, 115, 135) +\r\n      cond_cost_function(variation, 10, 15) +\r\n      cond_cost_function(vacancy, 0.15, 0.30)\r\n  )  \r\n)\r\n```\r\n\r\n\r\nRun experiment:\r\n\r\n```r\r\nresult <- nl_run(experiment, parallel = TRUE) \r\n# get the data (criteria)\r\ndat <- nl_get_result(result, type = \"criteria\") \r\n```\r\n\r\n\r\nPlot evaluation criteria on the model parameter space:\r\n\r\n```r\r\nlibrary(ggplot2)\r\nggplot(dat , aes(x = factor(scout_prob), y = factor(survival_prob), fill = pmin(cost, 30))) +\r\n  geom_tile() + theme_minimal() + labs(x = \"scout_prob\", y= \"survival_prob\") +\r\n  coord_fixed()\r\n```\r\n\r\n![](img/README-p9SplotParameterSpace-1.png) \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Parameter fitting and optimization / L-BFGS-B\r\nUsing experiment definition from \r\n[previous chapter: best-fit criteria function](#best-fit criteria function)\r\nwe could search the parameter space to optimize the cost function.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nWhen using optimization methods we can't pre-define parameter sets because they\r\nare selected as optimization runs. In this scenario the `nl_eval_run` function should be used instead of `nl_run`. \r\n\r\nThere are two differences:\r\n\r\n* `nl_run_eval` accepts a parameter set and returns a value \r\n* It requires NetLogo instance - user have to take care to initialize NetLogo and load the model before optimization begins and \r\nclose NetLogo when it is no longer needed (see functions `nl_eval_init` and `nl_eval_close`).\r\n\r\nUse `nl_eval_run` _parallel_ option when optimizing stochastic models\r\nwith more than a few repetitions needed to evaluate one parameter set. \r\n\r\nThere are many R packages for solving optimization problems \r\n(see [CRAN Task View](https://cran.r-project.org/web/views/Optimization.html)).\r\nThis example use **L-BFGS-B method** with standard `stats::optim` function.\r\nSee also Thiele, Kurth & Grimm (2014) chapter \r\n[2.28 Gradient and quasi-Newton methods](http://jasss.soc.surrey.ac.uk/17/3/11.html#sectionGQNM).\r\n\r\n\r\n```r\r\n# parameter range from experiment\r\nparam_range <- nl_get_param_range(experiment)   \r\n \r\n# initialize evaluation\r\ncl <- nl_eval_init(experiment, parallel = TRUE)\r\n#> [1] \"Creating sockets...\"\r\n\r\n# create callback container to spy what the optim function is doing\r\ntrace <- nl_eval_tracer(verbose = FALSE)\r\n\r\n#call optimisation function with L-BFGS-B method:\r\no_result <- optim(\r\n  par = c(0.5, 1.0),  \r\n  nl_eval_run, \r\n    experiment = experiment, criteria = \"cost\", \r\n    call_back = trace$add, parallel = TRUE, cluster = cl,\r\n  method = \"L-BFGS-B\",\r\n  lower = param_range$lower, upper = param_range$upper, \r\n  control = list(maxit = 200, trace = 1))\r\n#> final  value 0.023308 \r\n#> converged\r\n\r\nnl_eval_close(parallel = TRUE, cl)\r\n```\r\n\r\n\r\n```r\r\n#final result:\r\no_result\r\n#> $par\r\n#> [1] 0.266740 0.976674\r\n#> \r\n#> $value\r\n#> [1] 0.02330759\r\n#> \r\n#> $counts\r\n#> function gradient \r\n#>       22       22 \r\n#> \r\n#> $convergence\r\n#> [1] 0\r\n#> \r\n#> $message\r\n#> [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\"\r\n```\r\n\r\nThe `trace$add` function colected every iteration of `optim`. \r\n\r\n\r\n```r\r\ndat <- trace$get()\r\n\r\nlibrary(ggplot2)\r\n\r\nggplot(dat, aes(x=iter_id, y = result)) +\r\n  geom_step() +\r\n  labs(x = \"Iteration\", y = \"Evaluation result\")\r\n```\r\n\r\n![](img/README-p10plot-1.png) \r\n\r\nOptim iterations on parameter space:\r\n\r\n```r\r\n\r\n\r\nggplot(dat, aes(x = scout_prob, y = survival_prob, color = pmin(20,result))) +\r\n  #  geom_line(color = \"gray\", size = 1, ) +\r\n  geom_point(size = 3) +\r\n  geom_point(\r\n    color = \"red\", \r\n    data = data.frame(scout_prob = o_result$par[1], survival_prob = o_result$par[2]),\r\n    size = 20, shape = 4) +\r\n  theme_minimal()\r\n```\r\n\r\n![](img/README-unnamed-chunk-24-1.png) \r\n\r\n\r\n\r\n\r\n\r\n## References\r\n\r\n* Wilensky, U. (1999). NetLogo. http://ccl.northwestern.edu/netlogo/. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\r\n\r\n* Thiele, J. (2014) R Marries NetLogo: Introduction to the RNetLogo Package. Journal of Statistical Software 58(2) 1-41. http://www.jstatsoft.org/v58/i02/\r\n\r\n* Railsback, S. F., & Grimm, V. (2011). Agent-Based and Individual-Based Modeling: A Practical Introduction. Princeton University Press.\r\n\r\n* Thiele, J. C., Kurth, W., & Grimm, V. (2014). Facilitating Parameter Estimation and Sensitivity Analysis of Agent-Based Models: A Cookbook Using NetLogo and R. Journal of Artificial Societies and Social Simulation, 17(3), 11. http://jasss.soc.surrey.ac.uk/17/3/11.html\r\n\r\n* Wilensky, U. (1997). NetLogo Fire model. http://ccl.northwestern.edu/netlogo/models/Fire. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\r\n\r\n* Wilensky, U. (1997). NetLogo Ants model. http://ccl.northwestern.edu/netlogo/models/Ants. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\r\n\r\n* Wilensky, U. (2003). NetLogo Fur model. http://ccl.northwestern.edu/netlogo/models/Fur. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\r\n\r\n* Wilensky, U. (2005). NetLogo Preferential Attachment model. http://ccl.northwestern.edu/netlogo/models/PreferentialAttachment. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.\r\n\r\n* Wilensky, U., & Shargel, B. (2002). BehaviorSpace. Center for Connected Learning and Computer Based Modeling, Northwestern University, Evanston, IL. http://ccl.northwestern.edu/netlogo/behaviorspace.html\r\n\r\n\r\n## Resources\r\n\r\n* nlexperiment requires RNetLogo to connect to NetLogo\r\nhttps://cran.r-project.org/web/packages/RNetLogo/index.html\r\n\r\n* The parallel implementation of `nl_run` function is based on the RNetLogo vignette\r\nhttps://cran.r-project.org/web/packages/RNetLogo/vignettes/parallelProcessing.pdf\r\n\r\n* Basic ideas and principles of NetLogo experiment definition is taken from\r\nthe NetLogo's Behavior Space tool\r\nhttp://ccl.northwestern.edu/netlogo/docs/behaviorspace.html\r\n\r\n* This tutorial follows examples and methods from Thiele, Kurth & Grimm (2014)\r\narticle and its Supplementary Material\r\nhttp://sourceforge.net/projects/calibrationsensitivityanalysis/\r\n\r\n* This document was created with knitr package\r\nhttps://cran.r-project.org/web/packages/knitr/index.html\r\n\r\n* Graphics were created with ggplot2 package\r\nhttps://cran.r-project.org/web/packages/ggplot2/index.html\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}